UVM CODES FOR ETHERNET 10GE MAC

0.Interface : ( xge_mac_interface.sv )

`ifndef XGE_MAC_INTERFACE_SV
`define XGE_MAC_INTERFACE_SV

interface xge_mac_interface ( 	input bit clk_156m25 , 
				input bit clk_xgmii_rx,
				input bit clk_xgmii_tx,
				input bit wb_clk_i,
				ref logic reset_156m25_n,
				ref logic reset_xgmii_rx_n,
				ref logic reset_xgmii_tx_n,
				ref logic wb_rst_i ) ;
	logic pkt_rx_ren, pkt_tx_eop, pkt_tx_sop, pkt_tx_val;
	logic wb_cyc_i , wb_stb_i, wb_we_i , wb_ack_o , wb_int_o;
	logic pkt_rx_avail , pkt_rx_eop , pkt_rx_err , pkt_rx_sop , pkt_rx_val , pkt_rx_full;
	logic [63:0] pkt_tx_data , xgmii_rxd , pkt_rx_data , xgmii_txd ;
	logic [31:0] wb_dat_i, wb_dat_o;
	logic [7:0] wb_adr_i, xgmii_rxc , xgmii_txc;
	logic [2:0] pkt_tx_mod , pkt_rx_mod;
	
	parameter INPUT_SKEW = 1;
	parameter OUTPUT_SKEW = 1;
	
	clocking drv_cb @ (posedge clk_156m25 )
		default input #INPUT_SKEW;
		default output #OUTPUT_SKEW;
		input pkt_rx_avail;
		input pkt_rx_data;
		input pkt_rx_eop;
		input pkt_rx_err;
		input pkt_rx_mod;
		input pkt_rx_sop;
		input pkt_rx_val;
		output pkt_tx_full;
		output pkt_tx_data;
		output pkt_tx_eop;
		output pkt_tx_mod;
		output pkt_tx_sop;
		output pkt_tx_val;
		output pkt_rx_ren;
		input wb_ack_o;
		input wb_dat_o;
		input wb_int_o;
		input xgmii_txc;
		input xgmii_txd;
		output wb_adr_i;
		output wb_cyc_i;
		output wb_dat_i;
		output wb_stb_i;
		output wb_we_i;
		output xgmii_rxc;
output xgmii_rxd;
	endclocking
	modport driver_port ( clocking drv_cb );
	
	clocking mon_cb @( posedge clk_156m25 ) ;
	default input #INPUT_SKEW
	default output #OUTPUT_SKEW
	input pkt_rx_avail;
	input pkt_rx_data;
	input pkt_rx_eop;
	input pkt_rx_err;
	input pkt_rx_mod;
	input pkt_rx_sop;
	input pkt_rx_val;
	input pkt_rx_full;
	input wb_ack_o;
	input wb_dat_o;
	input wb_int_o;
	input xgmii_txc;
	input xgmii_txd;
	output pkt_rx_ren;
	input pkt_tx_data;
	input pkt_tx_eop;
	input pkt_tx_mod;
	input pkt_tx_sop;
	input pkt_tx_val;
	input wb_adr_i;
	input wb_cyc_i;
	input wb_dat_i;
	input wb_stb_i;
	input wb_we_i;
	input xgmii_rxc;
	input xgmii_rxd;
endclocking
modport monitor_port ( clocking mon_cb );

modport dut_port (
			output pkt_rx_avail;
			output pkt_rx_data;
			output pkt_rx_eop;
			output pkt_rx_err;
			output pkt_rx_mod;
			output pkt_rx_sop;
			output pkt_rx_val;
			output pkt_rx_full;
			output wb_ack_o;
			output wb_dat_o;
			output xgmii_txc;
			output wb_int_o;
			output xgmii_txd;
			input pkt_rx_ren;
			input pkt_tx_data;
			input pkt_tx_eop;
			input pkt_tx_mod;
			input pkt_tx_sop;
			input pkt_tx_val;
			input wb_adr_i;
			input wb_cyc_i;
			input wb_dat_i;
			input wb_stb_i;
			input wb_we_i;
			input xgmii_rxc;
			input xgmii_rxd;
			);
	
	initial
	begin	
		assign xgmii_rxc = xgmii_txc;
		assign xgmii_rxd = xgmii_txd;
	end
endinterface : xge_mac_interface
`endif

1.Top : (xge_test_top.sv ) 

`ifned XGE_TEST_TOP_SV
`define XGE_TEST_TOP_SV
`include “testcase.sv”

module xge_test_top;

logic clk_156m25 , clk_xgmii_rx , clk_xgmii_tx;
logic reset_156m25_n , reset_xgmii_rx_n , reset_xgmii_tx_n ;
logic pkt_rx_ren , pkt_tx_eop , pkt_tx_sop , pkt_tx_val; 
logic wb_clk_i,wb_cyc_i , wb_rst_i , wb_stb_i , wb_we_i;
logic [63:0] pkt_tx_data , xgmii_rxd;
logic [2:0] pkt_tx_mod;
logic [7:0] wb_adr_i , xgmii_rxc ;
logic [31:0] wb_dat_i;
logic pkt_rx_avail , pkt_rx_eop , pkt_rx_err , pkt_rx_sop , pkt_rx_val , pkt_tx_full ;
logic wb_ack_o , wb_int_o;
logic [63:0] pkt_rx_data , xgmii_txd;
logic [2:0] pkt_rx_mod ;
logic [31:0] wb_dat_o;
logic [7:0] xgmii_txc;

initial
begin
	clk_156m25 <= `0;
	clk_xgmii_tx <= `0;
	clk_xgmii_rx <= `0;
	wb_clk_i <= `0;
	forever
	begin
		#3200;
		clk_156m25 = ~ clk_156m25;
		clk_xgmii_tx = ~ clk_xgmii_tx;
		clk_xgmii_rx = ~ sclk_xgmii_rx;
wb_clk_i = ~ wb_clk_i ;
end
end
xge_mac_interface xge_mac_if ( 
				.clk_156m25 ( clk_156m25) ,
				.clk_xgmii_tx (clk_xgmii_tx) ,
				.clk_xgmii_rx (clk_xgmii_rx) ,
				. wb_clk_i (wb_clk_i) ,
				.reset_156m25_n (reset_156m25_n) ,
				.reset_xgmii_rx_n (reset_xgmii_rx_n) ,
				.reset_xgmii_tx_n (reset_xgmii_tx_n) ,
				.wb_rst_i (wb_rst_i)
				);

xge_mac xge_mac_dut (
			.pkt_rx_avail (xge_mac_if.pkt_rx_avail) ,
			pkt_rx_data (xge_mac_if. pkt_rx_data) , 
			pkt_rx_eop (xge_mac_if. pkt_rx_eop) , 
			pkt_rx_err (xge_mac_if. pkt_rx_err ) , 
			pkt_rx_mod (xge_mac_if. pkt_rx_mod )  , 
			pkt_rx_sop (xge_mac_if. pkt_rx_sop ) ,
			pkt_rx_val (xge_mac_if. pkt_rx_val ) , 
			pkt_rx_full (xge_mac_if. pkt_rx_full ) , 
			.wb_ack_o ( xge_mac_if.wb_ack_o ) ,
			.wb_dat_o ( xge_mac_if. wb_dat_o ) ,
			.wb_int_o ( xge_mac_if. wb_int_o) ,
			.xgmii_txc ( xge_mac_if. xgmii_txc ) ,
			.xgmii_txd ( xge_mac_if. xgmii_txd ) ,
			.clk_156m25 ( clk_156m25) ,
			.clk_xgmii_tx (clk_xgmii_tx) ,
			.clk_xgmii_rx (clk_xgmii_rx) ,
			.pkt_rx_ren ( xge_mac_if. pkt_rx_ren ) , 
			pkt_tx_data (xge_mac_if. pkt_tx_data) , 
			pkt_tx_eop (xge_mac_if. pkt_tx_eop) , 
			pkt_tx_mod (xge_mac_if. pkt_tx_mod )  , 
			pkt_tx_sop (xge_mac_if. pkt_tx_sop ) ,
			pkt_tx_val (xge_mac_if. pkt_tx_val ) , 
			.reset_156m25_n (reset_156m25_n) ,
			.reset_xgmii_rx_n (reset_xgmii_rx_n) ,
			.reset_xgmii_tx_n (reset_xgmii_tx_n) ,
			.wb_adr_i ( xge_mac_if. wb_adr_i) , 
			.wb_clk_i ( xge_mac_if. wb_clk_i ) , 
			. wb_cyc_i ( xge_mac_if. wb_cyc_i ) ,
			. wb_dat_i ( xge_mac_if. wb_dat_i ) ,
			. wb_rst_i  ( xge_mac_if. wb_rst_i ) ,
			. wb_stb_i ( xge_mac_if. wb_stb_i ) ,
			.wb_we_i ( xge_mac_if. wb_we_i ) ,
			.xgmii_rxc ( xge_mac_if. xgmii_rxc ) ,
			.xgmii_rxd ( xge_mac_if. xgmii_rxd ) ,

testcase pgm();

endmodule : xge_test_top 
`endif










2.Program file:	 (testcase.sv)

`ifndef TESTCASE_SV
`define TESTCASE_SV
program testcase();

import uvm_pkg::*;
`include “uvm_macros.svh”
‘include “testclass.sv”
initial
begin
	uvm_top.run_test();
end
endprogram
`endif

3.Testclass:	(testclass.sv)

`ifndef TESTCLASS_SV
`define TESTCLASS_SV

`include “reset_sequence.sv”
`include “wishbone_sequence.sv”
`include “packet_sequence.sv”
`include “env.sv”

class test_base extends uvm_test;
env m_env;
packet_sequence pkt_seq;
idle_sequence idle_seq;
txdata_sequence txdata_seq;

`uvm_component_utils(test_base);

function new ( input string name, input  uvm_component parent );
	super.new(name,parent);
endfunction : new

virtual function void build_phase(input uvm_phase phase);
	super.build_phase(phase);
m_env = env :: type_id :: create( “m_env”,this);
	pkt_seq = packet_sequence :: type_id :: create( “packet_seq_seq” );
 	idle_seq = idle_sequence :: type_id :: create( “idle_seq” );
	txdata_seq = txdata_sequence :: type_id :: create( “txdata_seq” );

	uvm_config_db #(virtual xge_mac_interface) :: set( this, “m_env.rst_agent.rst_drv”,”drv_vi”,xge_test_top.xge_mac_if);
	uvm_config_db #(virtual xge_mac_interface) :: set( this, “m_env.wshbn_agent.wshbn_mon”,”mon_vi”,xge_test_top.xge_mac_if);
	uvm_config_db #(virtual xge_mac_interface) :: set( this, “m_env.wshbn_agent.wshbn_drv”,”drv_vi”,xge_test_top.xge_mac_if);
	uvm_config_db #(virtual xge_mac_interface) :: set( this, “m_env.pkt_tx_agent_agent.pkt_tx_mon”,”mon_vi”,xge_test_top.xge_mac_if);
	uvm_config_db #(virtual xge_mac_interface) :: set( this, “m_env.pkt_tx_agent_agent.pkt_tx_drv”,”drv_vi”,xge_test_top.xge_mac_if);
	uvm_config_db #(virtual xge_mac_interface) :: set( this, “m_env.pkt_rx_agent.pkt_rx_mon”,”mon_vi”,xge_test_top.xge_mac_if);
	uvm_config_db #(virtual xge_mac_interface) :: set( this, “m_env.xgmii_tx_agent.xgmii_tx_mon”,”mon_vi”,xge_test_top.xge_mac_if);
	uvm_config_db #(virtual xge_mac_interface) :: set( this, “m_env.xgmii_rx_agent.xgmii_rx_mon”,”mon_vi”,xge_test_top.xge_mac_if);

	uvm_config_db #(uvm_object_wrapper) :: set( this, “m_env.rst_agent.rst_seqr.reset_phase”,”default_seqeunce”,reset_sequence :: get_type() );
	uvm_config_db #(uvm_object_wrapper) :: set( this, “m_env.wshbn_agent.wshbn_seqr.configure_phase”,”default_seqeunce”,wishbone_init_sequence :: get_type() );
	//uvm_config_db #(uvm_object_wrapper) :: set( this, m_env.pkt_tx_agent.pkt_tx_seqr.main_phase”,”default_sequence”,packet_sequence::get_type() );
	uvm_config_db #(int) :: set( null, ”.*”, “num_packets”, 10 );
endfunction : build_phase

virtual function void end_of_elaboration_phase(input uvm_phase phase);
	super.end_of_elaboration_phase(phase);
	`uvm_info( get_name(), “Printing Topology from end_of_elaboration_phase”, UVM_MEDIUM )
	if( uvm_report_enabled(UVM_MEDIUM) )
	begin
		uvm_top.print_topology();
	end
endfunction : end_of_elaboration_phase

virtual function void start_of_simulation_phase( input uvm_phase phase);
	super.start_of_simulation_phase(phase);
	`uvm_info( get_name(), “Printing factory from start of simulation phase”, UVM_MEDIUM);
	if(uvm_report_enabled(UVM_MEDIUM) )
	begin
		factory.print();
	end
endfunction : start_of_simulation_phase

virtual task run_phase( input uvm_phase phase);
	`uvm_info( get_name(), $sformatf(“%m”), UVM_HIGH);
endtask : run_phase

virtual task main_phase ( input uvm_phase phase);
	uvm_objection objection;
	super.main_phase(phase);
	objection = phase.get_objection();
	objection.set_drain_time(this,1us);
endtask main_phase

endclass : test_base


class bringup_packet_test extends test_base;
`uvm_component_utils (bringup_packet_test)

function new( input string name , input uvm_component parent);
	super.new(name, parent);
endfunction : new

virtual function void build_phase(input uvm_phase phase);
	super.build_phase ( phase);
endfunction : build_phase

virtual task main_phase (input uvm_phase phase);
super.main_phase (phase);
phase.raise_objection(this);
set_type_override_by_type ( packet :: get_type() , packet_bringup :: get_type() );
idle_seq.start( m_env.pkt_tx_agent.pkt_tx_seqr);
txdata_seq.start(m_env.pkt_tx_agent.pkt_tx_seqr);
phase.drop_objection(this);
phase.phase_done.set_drain_time(this,2ns);
endtask : main_phase

endclass : bringup_packet_test

class oversized_packet_test extends test_base;
`uvm_component_utils ( oversized_packet_test)

function new ( input string name, input uvm_component parent);
	super.new(name,parent);
endfunction : new

virtual function build_phase ( input uvm_phase phase);
	super.build_phase(phase);
endfunction : build_phase

virtual task main_phase (input uvm_phase phase);
	super.main_phase(phase);
	phase.raise_objection(this);	
		set_type_override_by_type ( packet :: get_type() , packet_oversized : get_type() );
		idle_seq.start( m_env.pkt_tx_agent.pkt_tx_seqr );
		txdata_seq.start ( m_env.pkt_tx_agent.pkt_tx_seqr);
	phase.drop_objection(this);
	phase.phase_done.set_drain_time(this,2ns);
endtask : main_phase

endclass : oversized_packet_test

class undersized_packet_test extends test_base;
`uvm_component_utils ( undersized_packet_test )

function new(input string name, input uvm_component parent);
	super.new(name,parent);
endfunction : new
virtual function void build_phase ( input uvm_phase phase);
	super.build_phase(phase);
endfunction : build_phase

virtual task main_phase ( input uvm_phase phase);
	super.main_phase(phase);
	phase.raise_objection ( this );
		set_type_override_by_type(packet :: get_type(), packet_undersized :: get_type() );
		idle_seq.start ( m_env.pkt_tx_agent.pkt_tx_seqr ) ;
		txdata_seq.start ( m_env.pkt_tx_agent.pkt_tx_seqr);
	phase.drop_objection( this );
	phase.phase_done.set_drain_time( this,2ns );
endtask : main_phase

endclass : undersized_packet_test

class missingsop_packet_test extends test_base;
`uvm_component_utils ( missingsop_packet_test)

function new (input string name , input uvm_component parent );
	super.new(name, parent);
endfunction : new

virtual function void build_phase ( input uvm_phase phase);
	super.build_phase(phase);
endfunction : build_phase

virtual task main_phase ( input uvm_phase phase);
	super.main_phase(phase);
	phase.raise_objection(this);
		set_type_override_by_type ( packet :: get_type(), packet_missing_sop :: get_type());
		idle_seq.start( m_env.pkt_tx_agent.pkt_tx_seqr );
		txdata_seq.start ( m_env.pkt_tx_agent.pkt_tx_seqr);
	phase.drop_objection (this);
	phase.phase_done.set_drain_time(this,2ns);
endtask : main_phase

endclass : missingsop_packet_test


class missingeop_packet_test extends test_base;
`uvm_component_utils ( missingeop_packet_test)

function new (input string name , input uvm_component parent );
	super.new(name, parent);
endfunction : new

virtual function void build_phase ( input uvm_phase phase);
	super.build_phase(phase);
endfunction : build_phase

virtual task main_phase ( input uvm_phase phase);
	super.main_phase(phase);
	phase.raise_objection(this);
		set_type_override_by_type ( packet :: get_type(), packet_missing_eop :: get_type());
		idle_seq.start( m_env.pkt_tx_agent.pkt_tx_seqr );
		txdata_seq.start ( m_env.pkt_tx_agent.pkt_tx_seqr);
	phase.drop_objection (this);
	phase.phase_done.set_drain_time(this,2ns);
endtask : main_phase

endclass : missingeop_packet_test

class zero_ipg_test extends test_base;
`uvm_component_utils ( zero_ipg_test ) 

function new ( input string name , input uvm_component parent);
	super.new (name,parent);
endfunction : new

virtual function void build_phase ( input uvm_phase phase );
	super.build_phase(phase);
endfunction : build_phase

virtual task main_phase ( input uvm_phase phase );
	super.main_phase(phase);
	phase.raise_objection(this);
		set_type_override_by_type ( packet :: get_type(), zero_ipg :: get_type());
		idle_seq.start( m_env.pkt_tx_agent.pkt_tx_seqr );
		txdata_seq.start ( m_env.pkt_tx_agent.pkt_tx_seqr);
	phase.drop_objection (this);
	phase.phase_done.set_drain_time(this,2ns);
endtask : main_phase

endclass : zero_ipg_test
`endif

4. Environment: (env.sv)
`ifndef ENV_SV
`define ENV_SV

`include “reset_agent.sv”
`include “wishbone_agent.sv”
`include “packet_tx_agent.sv”
`include “packet_rx_agent.sv”
`include “scoreboard.sv”

class env extends uvm_env;
`uvm_component_utils(env)

reset_agent rst_agent;
wishbone_agent wshbn_agent;
packet_tx_agent pkt_tx_agent;
packet_rx_agent pkt_rx_agt;
scoreboard scbd;

function new ( input string name , input uvm_component parent);
	super.new(name , parent);
endfunction : new

virtual function void build_phase( input uvm_phase phase);
	super.build_phase(phase);
	rst_agent = reset_agent :: type_id :: create ( “rst_agent”, this);
	wshbn agent = wishbone_agent :: type_id :: create(“wshbn_agent”,this);
	pkt_tx_agent = packet_tx_agent  :: type_id :: create ( “pkt_tx_agent”,this);
pkt_rx_agent = packet_rx_agent  :: type_id :: create ( “pkt_rx_agent”,this);
scbd = scoreboard :: type_id :: create ( “scbd” ,, this);
endfunction : build_phase()

virtual function void connect_phase( input uvm_phase phase );
	super.connect_phase(phase);
	pkt_tx_agent.ap_tx_agent.connect ( scbd.from_packet_tx_agent );
	pkt_rx_agent.ap_rx_agent.connect ( scbd.from_packet_rx_agent );
	wshbn_agent.ap_agent.connect ( scbd.from_wshbn_agent);
endfunction : connect_phase

virtual function void report_phase ( input uvm_phase phase);
	`uvm_info ( get_name(), $sprintf(“********************************”),UVM_NONE);
	
	`uvm_info ( get_name(), $psprintf(“Total packets sent to design = %d”,scb.num_packets),UVM_NONE);

	if(scbd.no_of_sop!=scbd.no_of_eop || scbd.no_of_sop!=scbd.num_packets || scbd_no_of_eop!=scbd_num_packets)
	begin	
		`uvm_error( get_name(), $psprintf(“Missing SOP or EOP packets found at end of test”));
		`uvm_error( get_name(), $psprintf(“Packet with SOP=%d Packets with EOP = %d”,scbd.no_of_sop,scbd.no_of_eop));
	end
	else if (scbd.no_of_sop == scbd.no_of_eop && scbd.no_of_sop==scbd.num_packets || scbd_no_of_eop==scbd_num_packets)
	begin
		`uvm_info( get_name(),$psprintf(“All packets are clean”),UVM_NONE);
		`uvm_info( get_name(),$psprintf(“Packet with SOP=%d Packets with EOP = %d”,scbd.no_of_sop,scbd.no_of_eop),UVM_NONE);
	end

	if( scbd.q_of_pkts_from_tx_size() )
	begin
		`uvm_error ( get_name() , $psprintf(“pkt_tx_agent_q_not_empty_at_end_of_test”))
		`uvm_error ( get_name() , $psprintf(“pkt_tx_agent_q_size = %d “,scbd.q_of_pkts_from_tx_size() );
	end
	if (scbd.q_no_of_pkts_from_rx.size() )
	begin	
		`uvm_error ( get_name() , $psprintf(“pkt_rx_agent_q_not_empty_at_end_of_test”))
		`uvm_error ( get_name() , $psprintf(“pkt_rx_agent_q_size = %d “,scbd.q_of_pkts_from_rx_size() );
	end
 
	if (scbd.mmatch == 0 && scbd.no_of_rx_pkt_rcvd == scbd.num_packets )
	begin
		`uvm_info ( get_name(), $psprintf(“ FINAL REPORT : ALL TESTCASES HAVE PASSED”),UVM_NONE);
	end
	else
	begin
		`uvm_error ( get_name(), $psprintf(“ FINAL REPORT : TEST FAILED”));
	end

endfunction : report_phase
	
endclass : env
`endif

5. Sequence item / transaction : (packet.sv)

`ifndef PACKET_SV
`define PACKET_SV

parameter ZERO = 4’b0000;
parameter ONE = 4’b0001;
parameter TWO = 4’b0010;
parameter THREE = 4’b0011;
parameter FOUR = 4’b0100;
parameter FIVE = 4’b0101;
parameter SIX = 4’b0110;
parameter SEVEN = 4’b0111;
typedef bit [71:0] bits72;

class packet extends uvm_sequence_item;
rand bit [47:0] mac_dst_addr;
rand bit [47:0] mac_src_addr;
rand bit [15:0] ether_type;
rand bit [7:0] payload [];
rand bit [31:0] ipg;
rand bits72 q_tx[$];
rand bit missing_sop;
rand bit missing_eop;

`uvm_object_utils_begin(packet)
`uvm_field_int (_mac_dst_addr, UVM_DEFAULT)
`uvm_field_int ( mac_src_addr, UVM_DEFAULT)
`uvm_field_int (ether_type , UVM_DEFAULT)
`uvm_field_array_int ( payload , UVM_DEFAULT)
`uvm_field_queue_int ( q_tx , UVM_DEFAULT)
`uvm_field_int ( ipg , UVM_DEFAULT)
`uvm_object_utils_end

constraint C_address {
			mac_dst_addr == 48’hAABBCCDDEEFF;
			mac_src_addr == 48’h112233445566;
		          }

constraint C_payload_size {
			      	payload.size() inside ([1:9000]};
			      	foreach ( payload[i] )
			      	{
					payload[j] inside { [8’h00:8’hFE] };
			     	}
			    }

constraint C_ipg { 
		    	ipg inside { [10 : 50] }
		  }

constraint C_ether_type {
				ether_type dist { 16’h0000:=34, 16’h0006:=33, 16’h88DD:=33 };
			 }
	
constraint C_proper_sop_eop_marks {
					missing_sop == 0;
					missing_eop ==0;
				           }

function new ( input string name = “packet” )
	super.new();
endfunction : new

endclass : packet

class packet_bringup extends packet;
`uvm_object_utils ( packet_bringup )

function new ( input string name = “packet_bringup” )
	super.new();
endfunction : new

constraint C_bringup
{
	mac_dst_addr == 48’hAABBCCDDEEFF;
	mac_src_addr == 48’h112233445566;
	ether_type dist { 16’h0000:=34, 16’h0006:=33, 16’h88DD:=33 };
	payload.size() == 46;
	foreach( payload[i] )
	{
		payload [j] == 8’hAB;
	}
	ipg == 10;
}
endclass : packet_bringup

class packet_oversized extends packet;
`uvm_object_utils ( packet_oversized )

function new ( input string name = “packet_oversized” )
	super.new(name);
endfunction : new

constraint C_payload_size {
	payload.size() inside { [ 1501:9000] };
	foreach ( payload [j] )
	{
		payload [j] == 8’hAB;
	}
}

constraint C_ipg {
			ipg==10;
		 }

endclass : packet_oversized


class packet_undersized extends packet;
`uvm_object_utils ( packet_undersized )

function new ( input string name = “packet_undersized” )
	super.new(name);
endfunction : new

constraint C_payload_size {
	payload.size() inside { [ 1:45] };
	foreach ( payload [j] )
	{
		payload [j] == 8’hAB;
	}
}

constraint C_ipg {
			ipg==10;
		 }

endclass : packet_undersized

class packet_missing_sop extends packet;
`uvm_object_utils ( packet_missing_sop )

function new ( input string name = “packet_missing_sop” )
	super.new(name);
endfunction : new

constraint C_payload_size 
{
	payload.size() insisde { [46:60] };
	foreach ( payload[j] )
	{
		payload[j] == 8’hAB;
	}
}
	
constraint C_ipg
{
	ipg == 10;
}

constraint C_proper_sop_eop_marks {
					missing_eop == 0;
					missing_sop dist {1:/40 , 0:/60 };
				           }

endclass : packet_missing_sop

class packet_missing_sop extends packet;
`uvm_object_utils ( packet_missing_eop )

function new ( input string name = “packet_missing_eop” )
	super.new(name);
endfunction : new

constraint C_payload_size 
{
	payload.size() insisde { [46:60] };
	foreach ( payload[j] )
	{
		payload[j] == 8’hAB;
	}
}
constraint C_ipg
{
	ipg == 10;
}
constraint C_proper_sop_eop_marks {
					missing_sop == 0;
					missing_eop dist {1:/40 , 0:/60 };
				           }
endclass : packet_missing_eop

class zero_ipg extends packet;
`uvm_object_utils( zero_ipg )
	
function new ( input string name = “zero_ipg”);
	super.new(name);
endfunction : new

constraint C_payload_size
{
	payload.size() inside { [46:60] };
	foreach ( payload [j] )
	{
		payload [j] == 8’hAB;
	}
}
constraint C_ipg {
		ipg ==10;
		}

endclass : zero_ipg
`endif

6.Packet_sequence / Generator : (packet_sequence.sv)

`ifndef PACKET_SEQUENCE_SV
`define PACKET_SEQEUNCE_SV
`include “packet.sv”
class packet_sequence extends uvm_sequence # (packet);
`uvm_objecta_utils( packet_sequence )

int I,j,k;
int pkt_size;
int pkt_size_mod8;
int pkt_size_div8;
int no_of_itrs
int last_full_row;
int unsigned num_packets = 10;

function new ( input string name = “packet_sequence” );
	super.new(name);
	`uvm_info ( get_name() , $sformatf ( “Hierarchy : %m”),UVM_HIGH );
endfunction : new

virtual task pre_start();
	if ( uvm_config_db #(int) :: get(null,  “.*” , “num_packets”, num_packets) )
	begin
		`uvm_info ( get_name() , $sformatf ( “SET NUM_PACKETS: %d”,num_packets),UVM_HIGH );
	end
	else
	begin
		`uvm_fatal ( get_name() , $sformatf ( “NOT SET NUM_PACKETS: %d”,num_packets ) );
	end
endtask : pre_start

endclass : packet_sequence

class idle_sequence extends packet_sequence;
`uvm_object_utils (idle_sequence)

function new(input string name = “idle_sequence”)
	super.new(name)
endfunction : new

task body();
	`uvm_create(req);
	`uvm_info ( get_name() ,$sformatf ( “IDLE SEQUENCE”),UVM_HIGH);
	req.ipg=0;
	req.mac_dst_addr = $random;
	req.mac_dst_addr = $random;
	req.q_tx[0] = ( {ZERO , ZERO , req.mac_dst_addr , req.mac_src_addr [ 47:32 ] } );
	req.print();
	`uvm_info ( get_name() , $sformatf ( “IDLE SEQUENCE” ) , UVM_HIGH );
	start_item (req);
	finish_item ( req );
	req.q_tx.delete();
endtask

endclas : idle_sequence

class txdata_sequence extends packet_sequence;
`uvm_object_utils ( txdat_sequence )

function new ( input string name = “ txdata_sequence”);
	super.new(name);
endfunction : new

task body();
	repeat(num_packets)
	begin
		`uvm_create ( req );
		assert ( req.randomize() );
		
		pkt_size = 6 + 6 + 2 + req.payload.size();
		pkt_size_mod8 = pkt_size % 8;
		pkt_size_div8 = pkt_size / 8;
		no_of_itrs = pkt_size_mod8 == 0 ? pkt_size_div8 : pkt_size_div8+1;
		last_full_row = pkt_size_mod8 == 0 ? no_of_itrs : no_of_itrs – 1;

		`uvm_info ( get_name() , $sformatf( “ START PROCESS TXDATA_SEQUENCE PRINT”),UVM_HIGH);
		$display(“payload size = %d “,req.payload.size() );
		$display(“ful packet size = %d “, pkt_size);
		$display(“full packet size div 8 = %d “ , pkt_size_div8 );
		$display(“full packet size mod 8 = %d “ , pkt_size_mod8 );
		$display(“No of iteration = %d “,no of itrs );
		$display(“last full row = %d” ,last_full_row);
	
		req.q_tx[0] = ( {ONE , ZERO , req.mac_dst_addr , req.mac_src_addr [47:32 ] } );
		req.q_tx[1] = ( { TWO , ZERO , req.mac_src_addr [ 31:0] , req.ether_type , req.payload [ 0 ] , req.payload [1 ] } );
		if ( pkt_size_mod8 == 0)
		begin
			k=last_full_row – 2;
			for ( i=2 ; i<= k ; i=i+1 ) 
			begin
				j = -6+(i-1)*8;
				req.q_tx[i] = ( {TWO , ZERO , req.payload [ j ] , req.payload[j+1] , req.payload [ j+2 ] , req.payload [ j+3 ] , req.payload [ j+4 ] , req.payload [ j+5 ] , req.payload [ j+6 ] , req.payload [ j+7 ] } );
			end
			i=last_full_row;
			j = -6 + (i-1) * 8;
			if ( pkt_size_mod8 == 1)
			req.q_tx [ i ] = ( {THREE , ONE , req.payload [ j ] , {7{8’hFF} } } );
			else  if ( pkt_size_mod8 == 2)
			req.q_tx [ i ] = ( {THREE , TWO , req.payload [ j ] , req.payload [ j+1 ] , {6{8’hFF) } } );
			else  if ( pkt_size_mod8 == 3)
			req.q_tx [ i ] = ( {THREE , THREE , req.payload [ j ] , req.payload [ j+1 ] , req.payload [ j+2 ] , {5{8’hFF} } } );
			else  if ( pkt_size_mod8 == 4)
			req.q_tx [ i ] = ( {THREE , FOUR , req.payload [ j ] , req.payload [ j+1 ] , req.payload [ j+2 ] , req.payload [ j+3 ] , {4{8’hFF} } } );
			else  if ( pkt_size_mod8 == 5)
			req.q_tx [ i ] = ( {THREE , FIVE , req.payload [ j ] , req.payload [ j+1 ] , req.payload [ j+2 ] ,  req.payload [ j+3 ] , req.payload [ j+4 ] , {3{8’hFF} } } );
			else  if ( pkt_size_mod8 == 6)
			req.q_tx [ i ] = ( {THREE , SIX , req.payload [ j ] , req.payload [ j+1 ] , req.payload [ j+2 ] ,  req.payload [ j+3 ] , req.payload [ j+4 ] , req.payload [ j+5 ] , {2{8’hFF} } } );
			else  if ( pkt_size_mod8 == 7)
			req.q_tx [ i ] = ( {THREE , SEVEN , req.payload [ j ] , req.payload [ j+1 ] , req.payload [ j+2 ] ,  req.payload [ j+3 ] , req.payload [ j+4 ] , req.payload [ j+5 ] , req.payload [ j+6 ] {8’hFF}  } );
		end
		start_item ( req ) ;
		req.print();
		`uvm_info ( get_name() , $sformatf ( “END : PROCESS TXDATA SEQUENCE PRINT”), UVM_HIGH );
		finish_item(req);
		req.q_tx_delete();
	end
endtask
	
endclass : txdata_sequence
`endif

7. Input agent : (packet_tx_agent.sv)
`ifndef PACKET_TX_AGENT_SV
`define PACKET_TX_AGENT_SV
`include “packet_tx_monitor.sv”
`include “packet_tx_driver.sv”

typedef uvm_sequencer #(packet) packet_tx_sequencer;

class packet_tx_agent extends uvm_agent;
`uvm_component_utils ( packet_tx_agent )

packet_tx_sequencer pkt_tx_seqr;
packet_tx_driver pkt_tx_drv;
packet_tx_monitor pkt_tx_mon;
uvm_analysis_port #(packet) ap_tx_agent;

function new (input string name = “packet_tx_agent”, input uvm_component parent );
	super.new(name , parent);
endfunction : new

virtual function void build_phase (input uvm_phase phase );
super.build_phase(phase);
	pkt_tx_seqr =  packet_tx_sequencer :: type_id :: create(“pkt_tx_seqr”, this);
	pkt_tx_drv = packet_tx_driver :: type_id :: create (“pkt_tx_drv”, this);
	pkt_tx_mon = packet_tx_monitor :: type_id :: create (“pkt_tx_mon”, this);
	ap_tx_agent = new (“ap_tx_agent”, this);
endfunction : build_phase

virtual function void connect_phase( input uvm_phase phase );
	super.connect_phase(phase);
	pkt_tx_drv.seq_item_port.connect ( pkt_tx_seqr.seq_item_export);
	this.ap_tx_agent = pkt_tx_mon.ap_tx_mon;
endfunction : connect_phase

endclass : packet_tx_agent
`endif

8. Driver : (packet_tx_driver.sv)
`ifndef PACKET_TX_DRIVER_SV
`define PACKET_TX_DRIVER_SV

class packet_tx_driver extends uvm_driver #(packet)
`uvm_component_utils (packet_tx_driver)
	
virtual xge_mac_interface drv_vi;
bits72 txdata;
intq_tx_size,i;
bit [3:0] type_of_pkt;
bit[2:0] mod_of_pkt;
bit [63:0] txdata_pkt;
bit pkt_with_missing_sop;
bit pkt_with_missing_eop;

function new (input string name = “packet_tx_driver”, input uvm_component parent ) ;
	super.new(name,parent);
endfunction : new

virtual function void build_phase (input uvm_phase phase);
	super.build_phase(phase);
	uvm_config_db #(virtual xge_mac_interface) :: get(this, “” ,”drv_vi”,drv_vi);
	if(drv_vi == null)
		`uvm_fatal( get_name() ,”Virtual interface not set”);
endfunction : build_phase

virtual task run_phase(input uvm_phase phase);
`uvm_info ( get_name() ,$sformatf ( “DRIVER RUN PHASE STARTED”), UVM_HIGH);
	forever
	begin
		seq_item_port.get_next_item(req);
		q_tx_size = req.q_tx.size();
		pkt_with_missing_sop = req.missing_sop;
		pkt_with_missing_eop = req.missing_eop;

		repeat(q_tx_size)
		begin
			@(drv_vi.drv_cb)
			txdata = req.q_tx.pop_front () ;
			type_of_pkt = txdata [71:68];
			mod_of_pkt = txdata [66:64];
			txdata_pkt = txdata [63:0];
			`uvm_info(get_name() , $sformatf(“%d: %d %d %h”, i , txdata[71:68] , txdata[67:64] , txdata[63:0] ),UVM_HIGH);
			
			if(type_of_pkt == 0)
			begin
				`uvm_info(  get_name() ,$sformatf(“DRIVING IDLE CYCLE”),UVM_HIGH )	
				drv_vi.drv_cb.pkt_tx_val <= 0;
				drv_vi.drv_cb.pkt_tx_sop <= 0;
				drv_vi.drv_cb.pkt_tx_eop <= 0;
				drv_vi.drv_cb.pkt_tx_mod <= $urandom_range(0,7);
				drv_vi.drv_cb.pkt_tx_data <= $random;
			end
			else if ( type_of_packet == 1 )
			begin
				`uvm_info ( gte_name() , $sformatf(“DRIVING SOP CYCLE”),UVM_HIGH);
				drv_vi.drv_cb.pkt_tx_val <= 1;
				if( packet_with_missing_sop == 0 )
				begin	
					`uvm_info( get_name() , $sformatf(“DRIVING SOP 1”),UVM_HIGH);
					drv_vvi.drv_cb.pkt_tx_sop <=1;
				end
				else
				begin
					`uvm_info( get_name() , $sformatf(“DRIVING SOP 0”),UVM_HIGH);
					drv_vvi.drv_cb.pkt_tx_sop <=0;
				end
				drv_vi.drv_cb.pkt_tx_eop = 0;
				drv_vi.drv_cb.pkt_tx_mod = $urandom_range (1,7);
				drv_vi.drv_cb.pkt_tx_tx_data = txdata [ 63: 0 ];
			end
			else if(type_of_pkt == 2)
			begin
				`uvm_info( get_name() , $sformatf(“DRIVING MOP cycle”),UVM_HIGH);
				drv_vi.drv_cb.pkt_tx_val <= 1;
				drv_vi.drv_cb.pkt_tx_sop <= 0;
				drv_vi.drv_cb.pkt_tx_eop <= 0;
				drv_vi.drv_cb.pkt_tx_mod <= $urandom_range(0,7);
				drv_vi.drv_cb.pkt_tx_data <= txdata[63:0];
			end
			else if (type_of_pkt == 3)
			begin
				`uvm_info( get_name() , $sformatf(“DRIVING EOP cycle”),UVM_HIGH);
				drv_vi.drv_cb.pkt_tx_val <= 1;
				drv_vi.drv_cb.pkt_tx_sop <= 0;
				if(pkt_with_missing_eop == 0)
				begin
					`uvm_info( get_name() , $sformatf(“DRIVING EOP 1”),UVM_HIGH);
					drv_if.drv_cb.pkt_tx_eop <= 1;
				end
				else
				begin
					`uvm_info( get_name() , $sformatf(“DRIVING EOP 0”),UVM_HIGH);
					drv_if.drv_cb.pkt_tx_eop <= 0;
				end
				drv_vi.drv_cb.pkt_tx_mod <= mod_of_pkt;
				drv_vi.drv_cb.pkt_tx_data <= txdata [63:0];
			end
		end
		repeat(req.ipg)
		begin	
			@(drv_vi.drv_cb);
			`uvm_info ( get_name() ,$sformatf(“Driving ipg cycle to design”), UVM_HIGH);
			drv_vi.drv_cb.pkt_tx_val <= 0;
			drv_vi.drv_cb.pkt_tx_sop <= $urandom_range(0,1);
			drv_vi.drv_cb.pkt_tx_eop <= $urandom_range(0,1);;
			drv_vi.drv_cb.pkt_tx_mod <= $urandom_range(0,7);
			drv_vi.drv_cb.pkt_tx_data <= $urandom_range [65535:0];
		end
		while (drv_vi.drv_cb.pkt_tx_full )
		begin
			@(drv_vi.drv_cb);
			drv_vi.drv_cb.pkt_tx_val <= 0;
			drv_vi.drv_cb.pkt_tx_sop <= $urandom_range(0,1);
			drv_vi.drv_cb.pkt_tx_eop <= $urandom_range(0,1);;
			drv_vi.drv_cb.pkt_tx_mod <= $urandom_range(0,7);
			drv_vi.drv_cb.pkt_tx_data <= $urandom_range [65535:0];
		end
	end
endtask : run_phase

endclass : packet_tx_driver
`endif
					


















9. Input monitor : ( packet_tx_monitor.sv ) 

`ifndef PACKET_TX_MONITOR_SV
`define PACKET_TX_MONITOR_SV

class packet_tx_monitor extends uvm_monitor;
`uvm_component_utils ( packet_tx_monitor )

virtual xge_mac_interface mon_vi;
uvm_analysis_port $(packet) ap_tx_mon;
packet_txmon_rcv_pkt;
bit pkt_in_progress, is_eop_pkt;
bit pkt_with_missing_sop,pkt_with_missing_eop;

function new (string name , uvm_component parent );
	super.new( name , parent );
	ap_tx_mon = new ( “ap_tx_mon”,this);
	txmon_rcv_pkt = packet :: type_id :: create ( “txmon_rcv_pkt” , this);
endfunction : new

virtual function void build_phase ( input uvm_phase phase)
	super.build_phase(phase);
	uvm_config_db #(virtual xge_mac_interface) :: get ( this, “” , “mon_vi” , mon_vi );
	if(mon_vi == null )
		`uvm_fatal ( get_name() , “Virtual interface for monitor not set!”);
endfunction : build_phase
	
virtual task run_phase ( input uvm_phase phase);
	`uvm_info ( get_name() , $sformatf ( ‘TXMONITOR RUN PHASE STARTED” ), UVM_HIGH ) ;	forever
	begin	
		@(mon_vi.mon_cb)
		pkt_with_missing_sop = req.missing_sop;
		pkt_with_missing_eop = req.missing_eop;
		
		if( mon_vi.mon_cb.missing_sop == 0)
		begin	
			`uvm_info( get_name(), $sformatf(“Driving SOP = 1”), UVM_HIGH);
			mon_vi.mon_cb.pkt_tx_sop <= 1;
		end
		else
		begin
			`uvm_info( get_name(), $sformatf(“Driving SOP = 0”), UVM_HIGH);
			mon_vi.mon_cb.pkt_tx_sop <= 0;
		end
		
		if(( mon_vi.mon_cb.missing_eop == 0)
		begin	
			`uvm_info( get_name(), $sformatf(“Driving EOP = 1”), UVM_HIGH);
			mon_vi.mon_cb.pkt_tx_eop <= 1;
		end
		else
		begin
			`uvm_info( get_name(), $sformatf(“Driving EOP = 0”), UVM_HIGH);
			mon_vi.mon_cb.pkt_tx_eop <= 0;
		end
	
		if(mon_vi.mon_cb.pkt_tx_val == 1)
		begin
			pkt_in_progress =1;
			`uvm_info ( get_name() , $psprintf ( “Valid tx_data packet”),UVM_HIGH)
		
			if(mon_vi.mon_cb.pkt_tx_sop && !mon_vi.mon_cb.pkt_tx_eop)
			begin
				pkt_in_progress = 1;
				is_eop_packet = 0;
				txmon_rcv_pkt.q_tx.push_back ( { ONE , ZERO , mon_vi.mon_cb.pkt_txdata } );
			end
			else if ( !mon_vi.mon_cb.pkt_tx_sop && !mon_vi.mon_cb.pkt_tx_eop )
			begin
				pkt_in_progress = 1;
				is_eop_pkt = 0;
				txmon_rcv_pkt.q_tx.push_back ( { TWO , ZERO , mon_vi.mon_cb.pkt_tx_data } );
			end
			else if ( !mon_vi.mon_cb.pkt_tx_sop && mon_vi.mon_cb.pkt_tx_eop)
			begin
				pkt_in_progress = 1;
				is_eop_pkt = 1;
				txmon_rcv_pkt.q_tx.push_back( {THREE, {1’b0, mon_vi.mon_cb.pkt_tx_mod},mon_vi.mon_cb.pkt_tx_data } );
			end
		end
		else if (mon_vi.mon_cb.pkt_tx_val == 0 )
		begin
			pkt_in_progress = 0;
			is_eop_pkt = 0;
			`uvm_info(get_name() , $psprintf(“Unknown tx_data packet”),UVM_HIGH )
		end
	
		if(pkt_in_progress == 1 && is_eop_pkt == 1)
		begin
			`uvm_info ( get_name() , $psprintf( “START TX MONITOR PRINT”), UVM_HIGH )
			txmon_rcv_pkt.print();
			ap_tx_mon.write(txmon_rcv_pkt);
			txmon_rcv_pkt.q_tx_delete();
		end
	end
endtask : run_phase

endclass : packet_tx_monitor

`endif

10. Output agent : (packet_rx_agent.sv)
	
`ifndef PACKET_RX_AGENT_SV
`define PACKET_RX_AGENT_SV
`include “packet_rx_monitor.sv”

class packet_rx_agent extends uvm_agent;

packet_rx_monitor pkt_rx_mon;
uvm_analysis_port #(packet) ap_rx_agent;

`uvm_component_utils (packet_rx_agent)

function new (input string name = “packet_rx_agent”, input uvm_component parent);
	super.new(name,parent);
endfunction : new

virtual function void build_phase( input uvm_phase phase);
	super.build_phase(phase);
	pkt_rx_mon = packet_rx_monitor :: type_id :: create (“pkt_rx_mon”, this);
	ap_rx_agent = new (“ap_rx_agent”, this);
endfunction : build_phase
	
virtual function void connect_phase (input uvm_phase phase);
	super.connect_phase(phase);
	this.ap_rx_agent = pkt_rx_mon.ap_rx_mon;
endfunction : connect_phase

endclass : packet_rx_agent	
`endif

11.Output monitor : (packet_rx_monitor)
`ifndef PACKET_RX_MONITOR_SV
`define PACKET_RX_MONITOR_SV

class packet_rx_monitor extends uvm_monitor;
`uvm_component_utils ( packet_rx_monitor)

virtual xge_mac_interface mon_vi;
uvm_analysis_port #(packet) ap_rx_mon;
packet rx_mon_rcv_pkt;

bit pkt_in_progress,is_eop_pkt;

function new( input string name = “packet_rx_monitor” , input uvm_component parent );
	super.new ( name , parent) ;
	rx_mon_rcv_pkt = packet :: type_id :: create ( “rxmon_rcv_pkt”, this);
endfunction : new

virtual function void build_phase( input uvm_phase phase);
	super.build_phase ( phase);
	ap_rx_mon = new ( “ap_rx_mon”, this );
	uvm_config_db #(virtual xge_mac_interface ) :: get ( this , “” , “mon_vi”, mon_vi );	
	if( mon_vi == null)
		`uvm_fatal ( get_name() , virtual interface handle not set”);
endfunction : build_phase

virtual task run_phase ( input uvm_phase phase) ;
packet rcv_pkt;
`uvm_info ( get_name() , $sformatf ( “HIERARCHY : %m),UVM_HIGH );
mon_vi.mon_cb.pkt_rx_en <= 1’b0;
forever
begin
	@(mon_vi.mon_cb)
	begin
		if ( mon_vi.mon_cb.pkt_rx_avail ) 
		begin
			mon_vi.mon_cb.pkt_rx_ren <= 1’b1;
		end

		if ( mon_vi.mon_c.pkt_rx_val == 1)
		begin
			pkt_in_progress = 1;
			is_eop_pkt = 0;
			`uvm_info ( get_name() , $psprintf ( “Valid rx_data packet”), UVM_HIGH)
			if ( mon_vi.mon_cb.pkt_rx_sop && ~mon_vi.mon_cb.pkt_rx_eop)
			begin
				`uvm_info ( get_name() , $psprintf(“”), UVM_HIGH);
				pkt_in_progress = 1;
				is_eop_pkt = 0;
				mon_vi.mon_cb.pkt_rx_ren = 1;
				rxmon_rcv_pkt.q_tx.push_back ( { ONE, ZERO , mon_vi.mon_cb.pkt_rx_data } );
			end
			else if ( !mon_vi.mon_cb.pkt_rx_sop && !mon_vi.mon_cb.pkt_rx_eop )	
			begin
				pkt_in_progress = 1;
				is_eop_pkt = 0;
				mon_vi.mon_cb.pkt_rx_ren = 1;
				rxmon_rcv_pkt.q_tx.push_back ( { TWO , ZERO , mon_vi.mon_cb.pkt_rx_data } );
			end
			else if ( !mon_vi.mon_cb.pkt_rx_sop && mon_vi.mon_cb.pkt_rx_eop )	
			begin
				pkt_in_progress = 1;
				is_eop_pkt =1;
				mon_vi.mon_cb.pkt_rx_ren = 0;
				rxmon_rcv_pkt.q_tx.push_back ( { THREE , {1’b0,mon_vi.mon_cb.pkt_rx_mod} , mon_vi.mon_cb.pkt_rx_data } );
			end
			else if ( mon_vi.mon_cb.pkt_rx_val == 0 )
			begin
				`uvm_info ( get_name() , $psprintf( “Invalid data packet “ ), UVM_HIGH );
				pkt_in_progress = 0;
				is_eop_pkt = 0;
			end
			else 
begin
				`uvm_info ( get_name () , $psprintf ( “Unknown rx_data_packet “ ),UVM_HIGH ) 
				pkt_in_progress = 0;
				is_eop_pkt = 0;
			end
			
			if ( pkt_in_progress == 1 && is_eop_pkt == 1)
			begin 
				`uvm_info ( get_name() , $psprintf ( “START_TX MONITOR PRINT “ ), UVM_HIGH ) 
				rxmon_rcv_pkt.print();
				`uvm_info ( get_name() , $psprintf ( “END RX_MONITOR PRINT” ) , UVM_HIGH )
				ap_rx_mon . write (rxmon_rcv_pkt ) ;
				rxmon_rcv_pkt.q_tx.delete();
			end
		end
	end
endtask : run_phase

11.1 Scoreboard : ( scoreboard.sv )	

`ifndef SCOREBOARD_SV
`define SCOREBOARD_SV
	
typedef uvm_in_order_comparator #(packet) packet_compaarator ;

class scoreboard extends uvm_scoreboard;

packet q_of_pkts_from_tx [ $ ];
packet q_of_pkts_from_rx [ $ ];
packet tx_packet , rx_packet , new_tx_packet , new_rx_packet , pop_tx_pkt , pop_rx_pkt ;
int pop_tx_pkt_qsize, pop_rx_pkt_qsize, mmatch;
int pop_tx_pkt_payload_size, pop_rx_pkt_payload_size;
int mod, j ,k , i ;
bit sop_found , eop_found ;
int no_of_sop , no_of_eop ;
 int num_packets , no_of_tx_pkt_rcvd , no_of_rx_pkt_rcvd ;

wishbone_item wshbn_read_q [$] ;
int unsigned m_matches ;
int unsigned m_mismatches;
int unsigned m_dut_errors;
int unsigned non_empty_queue;
uvm_event check_packet_event;
uvm_event check_wshbn_event;

`uvm_component_utils ( scoreboard )

`uvm_analysis_imp_decl ( from_pkt_tx_agent )
`uvm_analysis_imp_decl_from_pkt_tx_agent #(packet , scoreboard) from_pkt_tx_agent;
`uvm_analysis_imp_decl ( from_pkt_rx_agent )
`uvm_analysis_imp_decl_from_pkt_rx_agent #(packet , scoreboard) from_pkt_rx_agent;
`uvm_analysis_imp_from_wshbn_agent #(wishbone_item , scoreboard) from_wshbn_agent;

function new ( input string name = “scoreboard” , input uvm_component parent );
	super.new (name , parent );
endfunction : new

virtual function void build_phase ( input uvm_phase phase );
super.build_phase ( phase );
	from_pkt_tx_agent = new ( “from_pkt_tx_agent“ , this );
	from_pkt_rx_agent = new ( “from_pkt_rx_agent“ , this );
	from_wshbn_agent = new ( “from_wshbn_agent”, this);
	check_packet_event = new (“check_packet_event”);
	check_wshbn_event = new ( “check_wshbn_event” );

	if( uvm_config_db #(int) :: get ( null , “.*” , “num_packets” , num_packets ) )
	begin
		`uvm_info ( get_name() , $sformatf ( “SET NUM PACKETS : %d” ,num_packets ) , UVM_HIGH );
	end
	else
	begin
		`uvm_fatal ( get_name() , $sformatf ( “NOT SET NUM PACKETS “ ) );
	end
endfunction : build_phase 

virtual function write_from_pkt_tx_agent ( pkt_tx_agent ) ;
	no_of_tx_pkt_rcvd = no_of_tx_pkt_rcvd+1;
	`uvm_info ( get_name() , $psprintf( “Received %d pkt_tx packet” ,no_of_tx_pkt_rcvd) , UVM_HIGH ) 
	new_tx_pkt = packet :: type_id :: create ( “new_tx_pkt”,this);
	new_tx_pkt.copy(tx_packet);
	new_tx_pkt.print() ;
	q_of_pkts_from_tx.push_back ( new_tx_pkt );
endfunction : write_from_pkt_tx_agent

virtual function write_from_pjt_rx_agent ( packet_rx_agent) ;
	no_of_rx_pkt_rcvd = no_of_rx_pkt_rcvd+1;
	`uvm_info ( get_name() , $psprintf( “Received %d pkt_rx packet” ,no_of_rx_pkt_rcvd) , UVM_HIGH ) 
	new_rx_pkt = packet :: type_id :: create ( “new_rx_pkt”,this);
	new_rx_pkt.copy(rx_packet);
	new_rx_pkt.print() ;
	q_of_pkts_from_rx.push_back ( new_rx_pkt );
	check_packet_event.trigger ();
endfunction : write_from_pkt_rx_agent

virtual function write_from_wshbn_agent ( wishbone_item wshbn_xtxn );
	`uvm_info ( get_name() , $psprintf(“RECEIVED WISHBONE TRANSACTION”),UVM_FULL )
	wshbn_read_q.push_back(wshbn_xtxn);
	check_wshbn_event.trigger();
endfunction : write_from_wshbn_agent

virtual function void check_packet_queues();
	sop_found = 0;
	eop_found = 0;
	`uvm_info ( get_name() , $psprintf (“START SCOREBOARD CHECKIN OF %d packet”,no_of_tx_pkt_rcvd), UVM_HIGH );
	
`uvm_info( get_name() , $sformatf( “ START TX_SCB PRINT”), UVM_HIGH);
pop_tx_pkt = q_of_pkts_from_tx.pop_front();
pop_tx_pkt_q_size = pop_tx_pkt.q_tx.size();
if ( pop_tx_pkt.q_tx [ pop_tx_pkt_qsize – 1] [67:64] != 0)
	pop_tx_pkt_payload_size = (pop_tx_pkt_qsize * 8) – 14 – ( 8 -pop_tx_pkt.q_tx [ pop_tx_pkt_qsize – 1 ] [67:64] ) ;
else
	pop_tx_pkt_payload_size = (pop_tx_pkt_qsize * 8) – 14 ;

`uvm_info ( get_name() ,$psprintf ( “Current TXPKT payload size = %d”,pop_tx_pkt_payload_size), UVM_NONE ) ;
`uvm_info ( get_name() ,$psprintf ( “Current TXPKT queue size = %d”,pop_tx_pkt_qsize), UVM_NONE ) ;
pop_tx_pkt.print() ;
`uvm_info ( get_name() , $sformatf ( “END : TX SCB PRINT “ ), UVM_HIGH ) ;
`uvm_info ( get_name() , $sformatf ( “START : RX SCB PRINT “ ), UVM_HIGH ) ;	
pop_rx_pkt = q_of_pkts_from_rx.pop_front ();
pop_rx_pkt_qsize = pop_rx_pkt.q_tx.size() ;

if ( pop_rx_pkt. q_tx [ pop_rx_pkt_qsize – 1] [67:64] != 0)
pop_rx_pkt_payload_size = (pop_rx_pkt_qsize * 8) – 14 – ( 8 -pop_rx_pkt.q_rx [ pop_rx_pkt_qsize – 1 ] [67:64] ) ;
else
	pop_tx_pkt_payload_size = (pop_tx_pkt_qsize * 8) – 14 ;

`uvm_info ( get_name() ,$psprintf ( “Current RXPKT payload size = %d”,pop_rx_pkt_payload_size), UVM_NONE ) ;
`uvm_info ( get_name() ,$psprintf ( “Current RXPKT queue size = %d”,pop_rx_pkt_qsize), UVM_NONE ) ;
pop_rx_pkt.print() ;
`uvm_info ( get_name() , $sformatf ( “END : RXSCB PRINT”), UVM_HIGH );

if( pop_tx_pkt_payload_size >= 46)
begin
	if ( pop_tx_payload_size != pop_rx_pkt_payload_size && pop_tx_pkt_qsize!= pop_rx_pkt_qsize ) 
	begin
		`uvm_info ( get_name() , $sformatf(“tx/Rx payload and q size not matching although tx_payload_size > 46 tx_payloadd_size = %d rx_payload_size = %d tx_qsize = %d rx_qsize = %d”, pop_tx_pkt_payload_size,	pop_tx_pkt_payload_size, pop_tx_pkt_qsize, pop_rx_pkt_qsize), UVM_HIGH );
	end
	else if ( pop_tx_pkt_payload_size >= 4 && pop_tx_pkt_payload_size <=45 ) 
	begin
		`uvm_info ( get_name() , $sformatf(“tx/Rx payload and q size not matching although tx_payload_size > 46 tx_payloadd_size = %d rx_payload_size = %d tx_qsize = %d rx_qsize = %d”, pop_tx_pkt_payload_size,	pop_tx_pkt_payload_size, pop_tx_pkt_qsize, pop_rx_pkt_qsize), UVM_HIGH );
	end
end

if(pop_tx_payload_size >= 1 || pop_tx_pkt_payload_size <=45 )
begin
	`uvm_info( get_name() , $sformatf ( “Undersized packet size <= 3 tx_payload_size = %d rx_payload_size = %d”, pop_tx_pkt_payload_size , pop_rx_pkt_payload_size) ,UVM_HIGH);
end

if(pop_tx_pkt.q_tx [0] == pop_rx_pkt.q_tx [0] && popt_tx_pkt.q_tx[0] [71:68] == 4’b0001 )
begin	
	`uvm_info ( get_name() , $sformatf ( “SOP cycle : sequence matches tx_data = %h rx_data = h”, pop_tx_pkt.q_tx[0] , pop_rx_pkt.q_tx[0] ), UVM_HIGH );
	sop_found = 1;
	no_of_sop = no_of_sop+1;
end
else
begin
	sop_found = 0;
	if ( pop_tx_pkt.q_tx[0] [63:0] != pop_rx_pkt.q_tx [0] [63:0]
	begin
		`uvm_error ( get_name() , $sformatf(“SOP cycle : Pkt data mismatch tx_data = %h rx_data = %h”,pop_tx_pkt.q_tx [0] [63:0], pop_rx_pkt.q_tx [0] [63:0] ) ) ;
		mmatch = mmatch + 1;
	end
	if( pop_tx_pkt.q_tx[0] [71:68] != pop_rx_pkt.q_tx [0] [71:68]
	begin
		`uvm_error ( get_name() , $sformatf(“SOP cycle : Pkt data mismatch tx_data = %h rx_data = %h”,pop_tx_pkt.q_tx [0] [71:68], pop_rx_pkt.q_tx [0] [71:68] ) ) ;
		mmatch = mmatch + 1;
	end
	if( pop_tx_pkt.q_tx[0] [67:64] != pop_rx_pkt.q_tx [0] [67:64]
	begin
		`uvm_error ( get_name() , $sformatf(“SOP cycle : Pkt data mismatch tx_data = %h rx_data = %h”,pop_tx_pkt.q_tx [0] [67:64], pop_rx_pkt.q_tx [0] [67:64] ) ) ;
		mmatch = mmatch + 1;
	end
end

for( i = 1; i<=pop_tx_pkt_qsize – 2 ; i++)
begin
	if( pop_tx_pkt_q_tx[i] == pop_rx_pkt_q_tx[i] && pop_tx_pkt.q_tx[i] [71:68] == 4’b0010 )
	begin
		`uvm_info ( get_name() , $dformatf ( “ MOP CYCLE : SEQUENCE MATCHES txdata = %h rxdata = %h “, i , pop_tx_pkt.q_tx[i] ,  pop_rx_pkt.q_tx[i] ), UVM_HIGH );
	end
	else
	begin
		if ( pop_tx_pkt_q_tx[i] [63:0] != pop_rx_pkt_q_tx[i] [63:0] ) 
		begin
			`uvm_info ( get_name() , $dformatf ( “ MOP CYCLE : SEQUENCE MISMATCHES txdata = %h rxdata = %h “, i , pop_tx_pkt.q_tx[i] [63:0] ,  pop_rx_pkt.q_tx[i] [63:0] ), UVM_HIGH );
			mmatch = mmatch+1;
		end
		if ( pop_tx_pkt_q_tx[i] [71:68] != pop_rx_pkt_q_tx[i] [71:68] ) 
		begin
			`uvm_info ( get_name() , $dformatf ( “ MOP CYCLE : SEQUENCE MISMATCHES txdata = %h rxdata = %h “, i , pop_tx_pkt.q_tx[i] [71:68] ,  pop_rx_pkt.q_tx[i] [71:68] ), UVM_HIGH );
			mmatch = mmatch+1;
		end
		if ( pop_tx_pkt_q_tx[i] [67:64] != pop_rx_pkt_q_tx[i] [67:64] ) 
		begin
			`uvm_info ( get_name() , $dformatf ( “ MOP CYCLE : SEQUENCE MISMATCHES txdata = %h rxdata = %h “, i , pop_tx_pkt.q_tx[i] [67:64] ,  pop_rx_pkt.q_tx[i] [67:64] ), UVM_HIGH );
			mmatch = mmatch+1;
		end
	end
end

if( pop_tx_pkt_payload_size <= 45 ) 
begin
	for( j = pop_tx_pkt_qsize; j<=pop_rx_pkt_qsize-1 ; j=j+1 )
	begin
		if ( pop_rx_pkt.q_tx [j] [71:68] == 4’b0010)
		begin
			if ( pop_rx_pkt.q_tx [j] [63:0] == 64’h0)
			begin
				`uvm_info ( get_name() , $sprintf( “MOP CYCLE 0 PADDING” ), UVM_HIGH );
			end
			else
			begin
				`uvm_error (get_name() , $sformatf ( “MOP cycle DATAMISMATCH”), UVM_HIGH ) ;
			end
		end
	end
end
		i = pop_tx_pkt_qsize – 1;
		mod = pop_tx_pkt.q_tx [i] [67:64];
		if (	( mod == 1 && pop_tx_pkt.q_tx [63:56 ] == pop_ rx_pkt.q_tx [63:56 ] )||
    	( mod == 2 && pop_tx_pkt.q_tx [63:48 ] == pop_ rx_pkt.q_tx [63:48] ) || 
	( mod == 3 && pop_tx_pkt.q_tx [63:40 ] == pop_ rx_pkt.q_tx [63:40] ) ||
	( mod == 4 && pop_tx_pkt.q_tx [63:32 ] == pop_ rx_pkt.q_tx [63: 32 ] ) ||
	( mod == 5 && pop_tx_pkt.q_tx [63:24 ] == pop_ rx_pkt.q_tx [63: 24 ] ) ||
	( mod == 6 && pop_tx_pkt.q_tx [63:16 ] == pop_ rx_pkt.q_tx [63: 16 ] ) ||
	( mod == 7 && pop_tx_pkt.q_tx [63:8 ] == pop_ rx_pkt.q_tx [63:8 ] ) ||
	( mod == 0 && pop_tx_pkt.q_tx [63:0 ] == pop_ rx_pkt.q_tx [63:0 ] ) &&
	( pop_tx_pkt.q_tx [i] [71:68] = 4’b0011 ) )
begin
	`uvm_info ( get_name() , $sformatf(“EOP_cycle %d :sequence matches mod = %d tx_data = %h rx_data = %h”, i ,mod,pop_tx_pkt.q_tx[i] [63:0] , pop_rx_pkt.q_tx[i] [63:0] ) , UVM_HIGH );				
end
else 
begin
	mmatch = mmatch + 1;
	`uvm_error ( get_name () , $sformatf ( “SEQEUNCE MISMATCHES “);
		end
